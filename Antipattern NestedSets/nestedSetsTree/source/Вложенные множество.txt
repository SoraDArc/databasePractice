CREATE TABLE nested_sets (
	kingdom_id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
	level_kingdom TEXT NOT NULL,
	title TEXT NOT NULL,
	lft INTEGER NOT NULL,
	rgt INTEGER NOT NULL
);	

//Получение прямого родителя:
SELECT * FROM nested_sets
WHERE lft < (SELECT lft FROM nested_sets WHERE kingdom_id = 16)
AND rgt > (SELECT rgt FROM nested_sets WHERE kingdom_id = 16)
ORDER BY lft DESC
LIMIT 1;

//Получение всех родителей
WITH Dep AS (
	SELECT n1.kingdom_id, COUNT(n2.kingdom_id) AS depth 
	FROM nested_sets AS n1 
	JOIN nested_sets AS n2 
		ON n1.lft BETWEEN n2.lft AND n2.rgt
	GROUP BY n1.kingdom_id
)
SELECT lpad('  ', 5 * CAST(D.depth AS int)) || h2.title as title, h2.level_kingdom, h2.kingdom_id, h2.lft, h2.rgt
FROM nested_sets AS h1
	INNER JOIN nested_sets AS h2 
	ON h1.lft BETWEEN h2.lft AND h2.rgt
	JOIN Dep AS D 
	ON h2.kingdom_id = D.kingdom_id
WHERE h1.kingdom_id = 16
ORDER BY lft

//Получение прямых потомков
WITH Dep AS (
	SELECT n1.kingdom_id, COUNT(n2.kingdom_id) AS depth 
	FROM nested_sets AS n1 
	JOIN nested_sets AS n2 
		ON n1.lft BETWEEN n2.lft AND n2.rgt
	GROUP BY n1.kingdom_id
)
SELECT NS.kingdom_id, NS.level_kingdom, NS.title, NS.lft, NS.rgt FROM nested_sets AS NS
	JOIN Dep AS D 
		ON NS.kingdom_id = D.kingdom_id
WHERE lft > (SELECT lft FROM nested_sets WHERE kingdom_id = 1)
AND rgt < (SELECT rgt FROM nested_sets WHERE kingdom_id = 1)
AND d.depth = (SELECT depth + 1 FROM Dep WHERE kingdom_id = 1)
ORDER BY lft

//Получение всех потомков
WITH Dep AS (
	SELECT n1.kingdom_id, COUNT(n2.kingdom_id) AS depth 
	FROM nested_sets AS n1 
	JOIN nested_sets AS n2 
		ON n1.lft BETWEEN n2.lft AND n2.rgt
	GROUP BY n1.kingdom_id
), 
AllDescen as (
	SELECT h2.kingdom_id, h2.level_kingdom, h2.title, h2.lft, h2.rgt 
	FROM nested_sets AS h1
		INNER JOIN nested_sets AS h2 
		ON h2.lft BETWEEN h1.lft AND h1.rgt
	WHERE h1.kingdom_id = 1
)

SELECT lpad('  ', 5 * CAST(D.depth AS int)) || AD.title as title, AD.kingdom_id, AD.level_kingdom, AD.lft, AD.rgt FROM AllDescen AS AD 
	JOIN Dep AS D 
	ON AD.kingdom_id=D.kingdom_id
ORDER BY AD.lft

//Вставка листа ( к чему )
-- к узлу Моллюски id = 11 -> 19 - 26, то есть освобождаем 20 21
UPDATE nested_sets SET 
lft = CASE WHEN lft>=20 THEN lft + 2  -- 20 -> это lft к которому добавляем + 1 
	ELSE lft END,
rgt= rgt + 2 -- просто +2 
WHERE rgt>=20 -- 20 -> это lft к которому добавляем + 1 

INSERT INTO nested_sets (level_kingdom, title, lft, rgt) VALUES ('Класс','Новые существа', 20, 21) -- lft+1 and lft+2

//Удаление листа или узла -> 
DELETE FROM nested_sets WHERE kingdom_id = 1

//Удаление поддерева
--входные id -> 12
DELETE FROM nested_sets WHERE lft BETWEEN (SELECT lft FROM nested_sets WHERE kingdom_id = 12) AND (SELECT rgt FROM nested_sets WHERE kingdom_id = 12)

//Перемещение листа или узла -> (что - к чему) (Освобождение места аналогично вставке)
--Перемещение листа 24 Птицы 44 45 к узлу 2 Одноклеточные 2 9, для этого освобождаем 3 4   
UPDATE nested_sets SET lft = 
	CASE WHEN lft>=3
		THEN lft+2 
		ELSE lft 
		END, 
	rgt=rgt+2
WHERE rgt>=3

UPDATE nested_sets SET lft = 3, rgt=4 WHERE kingdom_id = 24 -- 3 и 4 освобождённе места ( получатся из: к чему добавляем left+1 и left+2) 

//Перемещение поддерева 
--Перемещаем 11 Моллюски 19 26 к узлу 2 Одноклеточные 2 9, освобождаем  3 10 
UPDATE nested_sets SET lft = 
	CASE WHEN lft>=3
		THEN lft+8 -- 26-19==7=10-3 (+1) к 7  =  8 - нужно выделить мест
		ELSE lft 
		END, 
	rgt=rgt+8 
WHERE rgt>=3

-- пересчитываем поддерево // Если значения получаемые в SET - отрицательные, то условие WHERE нужно менять на текущие позиции после смены. Если положительные то в WHERE будут изначальные позиции переносимого.
--Данные для SET считаются из освобождаемых мест  минус текущие данные перемещаемого
--Освобождаемые lft и rgt получаются из: к чему переносим, его данные: lft+1, lft + Сколько нужно мест 
UPDATE nested_sets SET lft = lft-24, rgt=rgt-24 -- Новые данные моллюсков после переноса будут lft - 27, rgt - 34 => 3 - 27, 10 -34 == (-24) 
WHERE lft BETWEEN 27 AND 34 -- цифры получились из позиции перемещаемого + 8
